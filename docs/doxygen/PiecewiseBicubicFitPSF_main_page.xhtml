<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sub-Pixel Photometry: PiecewiseBicubicFitPSF</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "ams.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sub-Pixel Photometry
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.xhtml');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('PiecewiseBicubicFitPSF_main_page.xhtml',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">PiecewiseBicubicFitPSF </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Fitting for position dependent values and derivatives of piecewise bicubic PSF models.</p>
<p><a class="anchor" id="md_PiecewiseBicubicFitPSF"></a></p>
<p>In the piecewise bicubic PSF model the PSF is split into a grid of cells and the intensity over each cell is assumed to be given by a bi-cubic function.</p>
<p>Requiring the continuity of the first order derivatives with respect to x and y as well as the cross derivative of the PSF dramatically reduces the number of free parameters. In fact the PSF is fully specified by the values, the x and y derivatives and the xy cross derivatives at the grid points.</p>
<p>Since we want the PSF to vary smoothly accross the image we will assume that these quantities are given by a polynomial expansion accross the image. Further, the grid points lying on the outside edge of the grid will be assumed to have a value and all derivatives equal to zero.</p>
<p>The grid giving the splitting of the PSF will be defined by a set of vertical boundaries with coordinates \( \{x_i\} \) (i=0...M) relative to the source center and horizontal boundaries with coordinates \( \{y_j\} \) (j=0...N) relative to the source center. Let \( \{V_{i,j}\} \) be the values, \( \{D^x_{i,j}\} \) the horizontal derivatives, \( \{D^y_{i,j}\} \) the vertical derivatives, and \( \{D^{xy}_{i,j}\} \) the cross derivatives of the PSF at the grid points. Let \( \mathbf{Q} \) be a vector of these quantities excluding those on the outside grid edge.</p>
<p>We need to impose that the integral of the PSF over the entire grid is one (scaling this by a factor is degenerate with scaling the amplitudes for all sources by the inverse factor). That can be imposed by noting that the integral of the PSF over the grid is given by \( \mathbf{I^TQ} \) for some column vector \( \mathbf{I} \). We then decompose \( \mathbf{Q}=\mathbf{I}/I^2+\sum q_i \mathbf{e}_i \) where \( I^2 \) is the square norm of \( \mathbf{I} \) and \( \mathbf{e}_i \) are an orthonormal basis for the space perpendicular to \( \mathbf{I} \). Note that the SVD decomposition of \( \mathbf{I}^T \) has \( \mathbf{U}=(1) \), \( \mathbf{S}=(I, 0, 0, ...) \) and the first columns of \( \mathbf{V} \) is \( \mathbf{I}/I \) and the remaining columns can be used as the \( \mathbf{e}_i \). We will then fit for the spatially dependent \( q_i \):</p>
<p class="formulaDsp">
\[ q_i=\sum_{k,l}q_{i,k,l}x^ky^l \]
</p>
<p>where \( x \) and \( y \) are the image coordinates of the center of the source for which the PSF is being constructed.</p>
<p>With these definitions, in order to fully specify PSF of each single source in an input image we need the quantities \( q_{i,k,l} \), where i is in the range 0 to (M-2)(N-2)-1, and the ranges for k and l depend on the order of the polynomial used to describe the PSF variability over the image, so we need to fit for those.</p>
<p>Note that the coefficients of the bi-cubic polynomials specifying the PSF in each grid cell depend linearly on the values and derivatives at the grid nodes, which can be reconstructed from the quantities we fit for. In turn, the integrals of the PSF over CCD (sub-)pixels depends linearly on the bi-cubic coefficients.</p>
<p>So if we somehow knew the fluxes of all the sources as well as their positions, we could constuct a matrix ( \( \mathbf{M} \)) such that: \( \mathbf{Mq}+\mathbf{\Delta} \) predicts the values of all image pixels assigned to any source scaled by the flux of that source. Where \( \mathbf{q} \) is the vector of the \( q_{i,k,l} \) unknowns and \( \Delta \) is the integral of a PSF specified entirely by \( \mathbf{I} \) over the corresponding pixel. So \( \mathbf{q} \) can be obtained by multiplying the rows of \( \mathbf{M} \) and \( \mathbf{\Delta} \) by the amplitude of the corresponding source and percforming a least squares fit. Since deriving the fluxes of the sources requires the PSF, we iterate. We begin by estimating the flux of each source by simply summing all the pixel values (in excess of the background) assigned to it or by aperture photometry. Then for each source we multiply the piece of the \( \mathbf{M} \) matrix that corresponds to that source's pixels by the current flux estimate and use the new matrix in a linear fit for the PSF. Finally, we update the flux estimates by using the new PSF model. This is repeated until the flux estimates stop changing too much.</p>
<h1>The Algorithm </h1>
<p>Directly constructing \( \mathbf{M} \) is counter productive. For even modest grids (say 12x12 cells) and a reasonable number of sources used from a real image (say 3000 each with an average of 50 pixels assigned to it) and a reasonable expansion order (say 4) would result in unmanageable matrix sizes ( \( 2\times10^9 \) elements in our example). Such matrices are hard to even allocate let alone solve. However, \( \mathbf{M} \) is of a special form which makes this unnecessary. In order to perform a least squares fit we need to multiply the RHS by \( \mathbf{M}^T \) (let the result be denoted by \( \mathbf{r&#39;} \) and then solve \( \mathbf{M}^T\,\mathbf{M}\,\mathbf{x}=\mathbf{r&#39;} \). The matrix \( \Lambda\equiv\mathbf{M}^T\,\mathbf{M} \) has only \( n^2K^2 \) elements ( \( 5.3 \times 10^7 \) in our example), which is reasonable to allocate and invert. Even more, calculating \( \mathbf{\Lambda} \) by first calculating \( \mathbf{M} \) is slower than the algorithm described below, and actually will dominate the computational time for non-trivial uses.</p>
<p>Let:</p><ul>
<li>\( \mathcal{O} \) - the polynomial expansion order</li>
<li>\( G_x,G_y \) - number of grid boundaries in the x and y direction respectively</li>
<li>S - number of sources</li>
<li>\( p_i \) - number of pixels assigned to the i-th source.</li>
<li>P - number of pixels in the input image assigned to all sources (i.e. \( P\equiv\sum_{i=0}^S p_i \))</li>
<li>K - number of terms in the polynomial expansion of a single PSF coefficient (i.e. K= \( \mathcal{O}+1)(\mathcal{O}+2)/2 \)).</li>
<li>n - number of parameters defining a single psf (i.e. n= \( 4(G_x-2)(G_y-2)-1 \))</li>
<li>\( r \) - vector of the background excess values of all pixels assigned to sources</li>
<li>\( \mathbf{I} \) - vector which when dotted with the PSF parameters ( \( \{V_{i,j}\} \), \( \{D^x_{i,j}\} \), \( \{D^y_{i,j}\} \), and \( \{D^{xy}_{i,j}\} \)) gives the integral of the PSF over the entire grid.</li>
<li>\( \Delta \) - Integrals of PSFs whose parameters are given by \( \mathbf{I}/I^2 \) over the source pixels.</li>
<li>\( \mathbf{\tilde{M}}^i \) - a set of matrices, one for each source, with each row consisting of the integrals over the same source pixel but with only one \( q_i \) being non-zero. The dimensions of the i-th matrix are \( p_i\times n \).</li>
<li>\( \mathbf{\Lambda}^i\equiv(\mathbf{\tilde{M}}^i)^T\mathbf{\tilde{M}}^i \)</li>
<li>\( \mathbf{\kappa^i} \) - a set of row-vectors, one for each source, containing the polynomial expansion terms (i.e. \( \left(1, x, y, x^2, xy, \cdots, y^\mathcal{O}\right) \))</li>
<li>\( f_i \) - current best estimate of the source flux</li>
</ul>
<p>With these definitions: </p><p class="formulaDsp">
\[ \mathbf{\Lambda}=\left(\begin{array}{ccccccc} \nwarrow &amp; \uparrow &amp; \nearrow &amp; \nwarrow &amp; \uparrow &amp; \nearrow \\ \longleftarrow &amp; \sum_{i=0}^S f_i^2 \Lambda^i_{1,1} (\mathbf{\kappa^i})^T \mathbf{\kappa^i} &amp; \longrightarrow &amp; \longleftarrow &amp; \sum_{i=0}^S f_i^2 \Lambda^i_{1,2} (\mathbf{\kappa^i})^T\mathbf{\kappa^i} &amp; \longrightarrow &amp; \cdots \\ \swarrow &amp; \downarrow &amp; \searrow &amp; \swarrow &amp; \downarrow &amp; \searrow \\ \\ \nwarrow &amp; \uparrow &amp; \nearrow &amp; \nwarrow &amp; \uparrow &amp; \nearrow \\ \longleftarrow &amp; \sum_{i=0}^S f_i^2 \Lambda^i_{2,1} (\mathbf{\kappa^i})^T\mathbf{\kappa^i} &amp; \longrightarrow &amp; \longleftarrow &amp; \sum_{i=0}^S f_i^2 \Lambda^i_{2,2} (\mathbf{\kappa^i})^T\mathbf{\kappa^i} &amp; \longrightarrow &amp; \cdots \\ \swarrow &amp; \downarrow &amp; \searrow &amp; \swarrow &amp; \downarrow &amp; \searrow \\ &amp; \vdots &amp; &amp; &amp; \vdots &amp; &amp; \ddots \end{array}\right) \]
</p>
<p>So the algorithm we will use for PSF fitting is as follows.</p>
<h2>One Time Initialization</h2>
<p>Overall Complexity: \( P\,n^2 \)</p>
<ol type="1">
<li>Obtain an initial estimate of the source fluxes (aperture photometry with flat PSF), the \( r \) and \( \Delta \) vectors. <b>Complexity</b>: large constant times S.</li>
<li><p class="startli">For each source:</p>
<p class="startli">2.1 construct the corresponding \( \mathbf{\tilde{M}^i} \) matrix and stack them together in \( \mathbf{\tilde{M}} \). <b>Complexity</b>: large constant times \( n\,S \).</p>
<p class="startli">2.2 For each source apply \( (\mathbf{\tilde{M}^i})^T \) to the corresponding piece of the \( r \) vector, storing the result as \( \mathbf{\tilde{r}}^i \) a part of a permanent vector \( \mathbf{\tilde{r}} \) (will have a total length of \( S\,n \)). <b>Complexity</b>: \( P\,n \).</p>
<p class="startli">2.3 Repeat \( \Delta \) storing the result as \( \mathbf{\tilde{\Delta}} \).</p>
<p class="startli">2.4 Calculate \( \mathbf{\tilde{\Lambda}^i} = (\mathbf{\tilde{M}^i})^T\,\mathbf{\tilde{M}^i} \) and store the result as part of the permament matrix \( \mathbf{\tilde{\Lambda}} \) (a stack of the individual \( \mathbf{\tilde{\Lambda}^i} \) matrices). <b>Complexity</b>: \( P\,n^2 \).</p>
</li>
<li>Calculate a stack of \( (\mathbf{\kappa^i})^T\mathbf{\kappa^i} \) matrices (<b>complexity</b>: \( S\,K^2 \)).</li>
</ol>
<h2>Estimates for The Expansion Coefficients of the PSF Parameters</h2>
<p>Overall Complexity \( S\,n^2\,K^2 \)</p>
<ol type="1">
<li>Compute the \( \mathbf{\Lambda} \) matrix as it is written above (<b>complexity</b>: \( S\,n^2\,K^2 \)).</li>
<li>Compute: <p class="formulaDsp">
\[ \mathbf{r&#39;}=\left(\begin{array}{c} \sum_{i=0}^S (\mathbf{\tilde{\kappa}^i})^T f_i (\tilde{r}^i_1-f_i\tilde{\Delta}^i_1)\\ \sum_{i=0}^S (\mathbf{\tilde{\kappa}^i})^T f_i (\tilde{r}^i_2-f_i\tilde{\Delta}^i_2)\\ \vdots\\ \sum_{i=0}^S (\mathbf{\tilde{\kappa}^i})^T f_i (\tilde{r}^i_n-f_i\tilde{\Delta}^i_n\\ \end{array}\right) \]
</p>
 <b>complexity</b>: \( n\,K \)</li>
<li>Use LDLT decomposition to solve for the (updated) expansion coefficients (<b>complexity</b>: \( n^3\,K^3 \)).</li>
</ol>
<h2>Estimates for the Source Amplitudes.</h2>
<p>This is a simple linear regression for the background excesses of each source using its current best fit PSF.</p>
<h1>Smoothing. </h1>
<p>In the case of fitting extremely sharp sources or very sparse images it is possible that there will not be enough stars or enough pixels within a star to constrain a grid, and yet there may be features of the PSF which require a fine grid to be used. In this case noise ends up being fitted and the resulting PSF has large amplitude high frequency components. This is clearly not physical and needs to be avoided in order to get stable photometry. In order to handle these cases piecewise bicubic PSF fitting support smoothing. This is implemented by adding the integral of the square of the second derivative in both x and y over the entire PSF to the function being minimized:</p>
<p class="formulaDsp">
\[ \tilde{\chi}^2 \equiv \frac{10^\sigma}{S}\sum_{s=1}^S \left( \frac{\partial^4 f_s(x,y)} {\partial x^2 \partial y^2} \right)^2 + \sum_{s=1}^S \sum_{j=1}^{p_i} \left(A_i\int_{pixel(i,j)} f_s(x,y) dx dy - r_i^j\right)^2 \]
</p>
<p>Adding the first term above, which is what is missing from the description above is actually quite simple. It can be expressed as the sum of terms containing constants and second order combinations of the PSF parameters. This in turn can be achieved by adding an extra \( \mathbf{\tilde{M}}^i \) matrix and a corresponding source with all zero fluxes. However, this extra matrix will not be multiplied by a \( \kappa^T\kappa \), but instead by the average of that over all sources.</p>
<p>In order to add the first we need to write it as a sum of squares of the difference between a linear transformation of the \( q_i \) parameters and some right hand side vector.</p>
<p>In the following let i and j be indices identifyin a grid cell (i is the grid column and j is the grid row) and let \( c^{i,j}_{m,n;s} \) be the coefficient in front of \( x^m y^n \) term in the PSF funciton of source number \(s\) over the \( (i,\ j) \) cell. In what follows we will drop the i, j and s indices for shorter notation. Then:</p>
<p class="formulaDsp">
\begin{eqnarray*} \int_{grid} dx dy \left( \frac{\partial^4 f_s(x,y)}{\partial x^2 \partial y^2} \right)^2 = \sum_{i,j} \Bigg(&amp;&amp; \\ &amp;&amp; 16 c_{2,2}^2 w h \\ &amp;&amp; + 48 c_{2,3}^2 w h^3 \\ &amp;&amp; + 48 c_{3,2}^2 w^3 h \\ &amp;&amp; + 144 c_{3,3}^2 w^3 h^3 \\ &amp;&amp; + 48 c_{2,2} c_{2,3} w h^2 \\ &amp;&amp; + 48 c_{2,2} c_{3,2} h^2 w \\ &amp;&amp; + 72 c_{2,2} c_{3,3} w^2 h^2 \\ &amp;&amp; + 72 c_{2,3} c_{3,2} w^2 h^2 \\ &amp;&amp; + 144 c_{2,3} c_{3,3} w^2 h^3 \\ &amp;&amp; + 144 c_{3,2} c_{3,3} w^3 h^2 \\ \Bigg) \\ = \sum_{i,j} w h \Bigg(&amp;&amp; \\ &amp;&amp; 16 c_{2,2}^2 \\ &amp;&amp; + 48 c_{2,3}^2 h^2 \\ &amp;&amp; + 48 c_{3,2}^2 w^2 \\ &amp;&amp; + 144 c_{3,3}^2 w^2 h^2 \\ &amp;&amp; + 48 c_{2,2} c_{2,3} h \\ &amp;&amp; + 48 c_{2,2} c{3,2} w \\ &amp;&amp; + 72 c_{2,2} c_{3,3} w h \\ &amp;&amp; + 72 c_{2,3} c_{3,2} w h \\ &amp;&amp; + 144 c_{2,3} c_{3,3} w h^2 \\ &amp;&amp; + 144 c_{3,2} c_{3,3} w^2 h \\ \Bigg) \end{eqnarray*}
</p>
<p> where \( w,\ h \) are the width and height of the grid cell. Since this is a quadratic form in \( c_{m,n} \), it can be written as: </p><p class="formulaDsp">
\[ \int_{grid} dx dy \left( \frac{\partial^4 f_{x_0, y_0}(x,y)}{\partial x^2 \partial y^2} \right)^2 = \mathbf{C}^T \mathbf{A} \mathbf{C} \]
</p>
<p> where \( \mathbf{C}^T=(C^{0,0}_{2,2}, C^{0,0}_{2,3}, C^{0,0}_{3,2}, C^{0,0}_{3,3}, C^{1,0}, \ldots) \) and A is a symmetric matrix which consists of matrices of the following form along its diagonal: </p><p class="formulaDsp">
\[ \mathbf{A_{cell}}=w h \left(\begin{array}{cccc} 16 &amp; 24 h &amp; 24 w &amp; 36 w h \\ 24 h &amp; 48 h^2 &amp; 36 w h &amp; 72 w h^2 \\ 24 w &amp; 36 w h &amp; 48 w^2 &amp; 72 w^2 h \\ 36 w h &amp; 72 w h^2 &amp; 72 w^2 h &amp; 144 w^2 h^2 \end{array}\right) \]
</p>
<p> Since \( \mathbf{A} \) is symmetric it can be written as \( \mathbf{E}^T \mathbf{\Lambda} \mathbf{E} \) where \( \mathbf{E} \) is orthogonal and \( \mathbf{\Lambda} \) is diagonal containing the eigenvalues of \( \mathbf{A} \). Which can clearly be written as \( \mathbf{A} = \mathbf{B}^T\mathbf{B} \) with \( \mathbf{B}=\sqrt{\mathbf{\Lambda}} \mathbf{E} \).</p>
<p>Further: </p><p class="formulaDsp">
\[ \mathbf{C} = \mathbf{\Phi} \mathbf{q} = \mathbf{\Phi}\left( \mathbf{I}/I^2 + \sum_{i,k} q_{i,k} \kappa_k \mathbf{e}_i \right) \]
</p>
<p>So we end up with: </p><p class="formulaDsp">
\[ S\equiv \sum_{s=1}^S \int_{grid} dx dy \left( \frac{\partial^4 f_s(x,y)}{\partial x^2 \partial y^2} \right)^2 = \sum_{s=1}^S \sum_{c} \left[ \sum_{d,e} B_{c,d} \Phi_{d,e} \left( I_e/I^2 + \sum_{i,k} q_{i,k} \kappa^s_k \mathbf{e}_{i,e} \right) \right]^2 \]
</p>
<p>To find the minimum differentiate: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial S}{\partial q_{\sigma,\mu}} &amp;=&amp; 2 \sum_{s=1}^S \sum_{c} \left[ \sum_{d,e} B_{c,d} \Phi_{d,e} \left( I_e/I^2 + \sum_{i,k} q_{i,k} \kappa^s_k \mathbf{e}_{i,e} \right) \right] \left[ \sum_{\delta,\varepsilon} B_{c,\delta} \Phi_{\delta,\varepsilon} \left( \kappa^s_\mu e_{\sigma,\varepsilon} \right) \right]\\ &amp;=&amp; 2 \sum_{s=1}^S \kappa^s_{\mu} \mathbf{e}_{\sigma}^T\mathbf{\Phi}^T\mathbf{B}^T \mathbf{B} \mathbf{\Phi} \left( \mathbf{I}/I^2 + \sum_{i,k} q_{i,k} \kappa^s_k \mathbf{e}_{i} \right)\\ &amp;=&amp; \frac{2}{I^2} \mathbf{e}_{\sigma}^T\mathbf{\Phi}^T\mathbf{A}\mathbf{\Phi} \mathbf{I} \sum_{s=1}^S \kappa^s_{\mu} + \frac{2}{I^2} \mathbf{e}_{\sigma}^T\mathbf{\Phi}^T\mathbf{A}\mathbf{\Phi} \sum_{s=1}^S \sum_{i,k} q_{i,k} \kappa^s_{\mu} \kappa^s_k \mathbf{e}_{i} \end{eqnarray*}
</p>
<p> The first term needs to be added to the \( \mathbf{r}&#39; \) vector and the matrix identified by the second term must be added to the \( \mathbf{\Lambda} \) matrix.</p>
<p>Conveniently, neither correction depends on the current values of the parameters, so we can compute those once for a given grid and simply add them at each step, thus not resulting in any significant overhead to the fitting. Further the non-smoothing algorithm already computes the bicubic coefficients over each grid cell for the selected basis vector so we have \( \mathbf{\Phi} \mathbf{I}/I^2 \) and \( \mathbf{\Phi} \mathbf{e}_i \) for all \( \mathbf{e}_i \). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 15 2025 15:36:41 for Sub-Pixel Photometry by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
