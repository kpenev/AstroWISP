plugins {
    id 'cpp'
    id "org.ysb33r.doxygen" version "0.4"
}

import org.gradle.internal.os.OperatingSystem;

model {
    buildTypes {
        debug
        release
        profile
    }

    //Common configuration for all binaries
    binaries {
        all {

            if(buildType == buildTypes.release) {
                cppCompiler.define "NDEBUG"
            } else if(buildType == buildTypes.debug) {
                cppCompiler.define "DEBUG"
                cppCompiler.define "VERBOSE_DEBUG"
            }

            if (toolChain in Gcc || toolChain in Clang) {
                if (toolChain in Gcc)
                    cppCompiler.define "TOOLCHAIN_GCC"
                else
                    cppCompiler.define "TOOLCHAIN_CLANG"

                cppCompiler.args "-W", "-Wall", "-fvisibility=hidden"

                getGSLLinkerArgs().each{linker.args it}
                linker.args "-l" + ensureLibraryVersion(
                    "boost_program_options",
                )
                linker.args "-l" + ensureLibraryVersion("gfortran")
                linker.args "-l" + ensureLibraryVersion("cfitsio")
                linker.args "-l" + ensureLibraryVersion("hdf5")
                linker.args "-l" + ensureLibraryVersion("hdf5_cpp")
                linker.args "-l" + ensureLibraryVersion("z")

                if(buildType == buildTypes.release) {
                    cppCompiler.args "-O3"
                } else {
                    cppCompiler.args "-ggdb", "-pg"
                    if(buildType == buildTypes.debug) {
                        cppCompiler.args "-O0", "-fno-inline"
                        cppCompiler.define "TRACK_PROGRESS"
                    }
                }
            } else if (toolChain in VisualCpp ) {
                if(buildType == buildTypes.debug) {
                    cppCompiler.args '/Zi'
                    cppCompiler.define 'DEBUG'
                    linker.args '/DEBUG'
                }
            }

        }
        withType(StaticLibraryBinarySpec) {
            cppCompiler.args '-fPIC'
        }

    }

    components {
        eigen(NativeLibrarySpec) {
            sources.cpp {
                source {}
                exportedHeaders {
                    srcDir "src/third_party_libs/Eigen"
                }
            }
        }
        superphot(NativeLibrarySpec) {
            sources.cpp {
                lib library: "eigen"
                source {
                    srcDir "src/Core"
                    include "**/*.cpp"
                }
                source {
                    srcDir "src/IO"
                    include "**/OutputArray.cpp"
                }
                source {
                    srcDir "src/Background"
                    include "**/*.cpp"
                }
                source {
                    srcDir "src/PSF"
                    include "**/*.cpp"
                }
                source {
                    srcDir "src/FitPSF"
                    include "**/*.cpp"
                    exclude "**/*SDK*.cpp"
                    exclude "**/fitpsf.cpp"
                }
                source {
                    srcDir "src/SubPixPhot"
                    include "**/*.cpp"
                }
                source {
                    srcDir "src/Core"
                    include "**/*.cpp"
                }
                exportedHeaders {
                    srcDir "src/Background/"
                }
                exportedHeaders {
                    srcDir "src/PSF/"
                }
                exportedHeaders {
                    srcDir "src/IO/"
                }
                exportedHeaders {
                    srcDir "src/FitPSF/"
                }
            }
        }
    }
}

doxygen {
    generate_html true
    template "documentation/doxygen/Doxyfile"
    source "src/Background"
    source "src/Core"
    source "src/FitPSF"
    source "src/FitSubpix"
    source "src/IO"
    source "src/PSF"
    source "src/SubPixPhot"
    source "src/SubtractPSF"
    source "src/VisualizePSFMap"
    source "documentation/doxygen"
    include "**/*.h"
    include "**/*.cpp"
    include "**/*.py"
    include "**/*.md"
}

def findLibraryLinux(String libNameStart)
{
    def libInfoList
    def bestMatch = false
    def absLibFileName
    def multipleCandidates = false
    try {
        libInfoList = "ldconfig -p".execute().text.split('\n')
    } catch (Exception ex) {
        throw new ProjectConfigurationException(
            "Failed to execute command: ldconfig -p",
            new NullPointerException()
        )
    }
    def libSearch = ~(
        "lib(?<name>${libNameStart}.*)\\.so\\.(?<version>[0-9.]*)\\s+.*=>"
    )
    for(String libInfo : libInfoList) {
        def match = libInfo =~ libSearch
        if(match) {
            absLibFileName = libInfo.split('=>')[1].trim()
            if(match.group("name") == libNameStart)
                return [match.group("name"),
                        match.group("version"),
                        absLibFileName]
            if(bestMatch) {multipleCandidates = true}
            bestMatch = match
        }
    }
    if(bestMatch) {
        if(multipleCandidates) {
            throw new ProjectConfigurationException(
                "Multiple link candidates found for library "
                +
                "${libNameStart}:\n",
                new NullPointerException()
            )
        }
        return [bestMatch.group("name"),
                bestMatch.group("version"),
                absLibFileName]
    } else {
        throw new ProjectConfigurationException(
            "No candidate ${libNameStart} library found!",
            new NullPointerException()
        );
    }
}

def findLibraryMacOS(String libName)
{
    def libFullPath
    def ldCommand = "ld -l${libName} -dylib -t"
    for(String path : System.env.LIBRARY_PATH.split(':')) {
        if(path) ldCommand += " -L${path}"
    }

    libFullPath = ldCommand.execute().text.trim()
    if(!libFullPath) 
        throw new ProjectConfigurationException(
            "No candidate ${libName} library found!",
            new NullPointerException()
        );

    def versionSearch = ~(
        "${libName}[0-9.]*.dylib \\(.* current version (?<version>[0-9.]*)"
    )

    def otoolOutput = (
        "otool -L ${libFullPath}".execute().text.split('\n')
    )
    for(String line : otoolOutput) {
        def match = line =~ versionSearch
        if(match) return [libName, match.group("version"), libFullPath]
    }
    throw new ProjectConfigurationException(
        "Failed to determine the version of ${libName} library!",
        new NullPointerException()
    );
}

def findLibrary(String libNameStart)
{
    if(OperatingSystem.current().isLinux())
        return findLibraryLinux(libNameStart)
    else if(OperatingSystem.current().isMacOsX())
        return findLibraryMacOS(libNameStart)
    else {
        throw new ProjectConfigurationException(
            "Compiling on non-linux or Mac operating systems not currently "
            +
            "supported!",
            new NullPointerException()
        );
    }
}

def ensureLibraryVersion(String libNameStart,
                         Map versionRange = [:])
{
    def(String libName,
        String libVersion,
        String libAbsFileName) = findLibrary(libNameStart)
    if(libVersion == "0.0.0") return libName
    if(versionRange.containsKey('min'))
        assert(libVersion >= versionRange['min'])
    if(versionRange.containsKey('max'))
        assert(libVersion <= versionRange['max'])
    return libName
}

def getGSLLinkerArgs()
{
    if(OperatingSystem.current().isWindows()) {
        return ["-lgsl", "-lgslcblas"]
    } else {
        try {
            return "gsl-config --libs".execute().text.tokenize()
        } catch (ReportedException) {
            throw new MissingResourceException(
                "Unable to configure linking with GSL: gsl-config --libs " +
                "failed!"
            );
        }
    }
}

task showCompilerOptions {
   doLast {
      println '\n-----------------------------------------------------\n'
      println 'Compiler options:'
      FileTree tree = fileTree('build').include('**/options.txt')
      // Iterate over the contents of a tree
      tree.each {File file ->
          println 'Content of file ' + file + ':\n'
          println file.text
          println '------\n'
      }
   }
}

task showCompilerOutput {
   dependsOn showCompilerOptions
   doLast {
      println '\n-----------------------------------------------------\n'
      println 'Compiler output:'
      FileTree tree = fileTree('build').include('**/output.txt')
      // Iterate over the contents of a tree
      tree.each {File file ->
          println 'Content of file ' + file + ':\n'
          println file.text
          println '------\n'
      }
   }
}
