plugins {
    id 'cpp'
    id "org.ysb33r.doxygen" version "0.4"
}

import org.gradle.internal.os.OperatingSystem;


model {
    buildTypes {
        debug
        release
        profile
    }

    platforms {
        x64 {
              architecture "x64"
        }
    }
    //Common configuration for all binaries
    binaries {
        all {

            if(buildType == buildTypes.release) {
                cppCompiler.define "NDEBUG"
                cppCompiler.define "TRACK_PROGRESS"
            } else if(buildType == buildTypes.debug) {
                cppCompiler.define "DEBUG"
                cppCompiler.define "VERBOSE_DEBUG"
                cppCompiler.define "TRACK_PROGRESS"
            }

            if (toolChain in Gcc || toolChain in Clang) {
                if (toolChain in Gcc) {
                    cppCompiler.args "-std=gnu++98"
                    cppCompiler.define "TOOLCHAIN_GCC"
                } else
                    cppCompiler.define "TOOLCHAIN_CLANG"

                cppCompiler.args "-W", "-Wall", "-fvisibility=hidden"
                linker.args "-l" + ensureLibraryVersion(
                    "boost_program_options",
                )

                if(buildType == buildTypes.release) {
                    cppCompiler.args "-O3"
                } else {
                    cppCompiler.args "-ggdb", "-pg"
                    if(buildType == buildTypes.debug) {
                        cppCompiler.args "-O0", "-fno-inline"
                        cppCompiler.define "TRACK_PROGRESS"
                    }
                }
            } else if (toolChain in VisualCpp) {
                cppCompiler.define 'TOOLCHAIN_MSVC'
                cppCompiler.define '_USE_MATH_DEFINES'
                cppCompiler.define 'BOOST_RESULT_OF_USE_TR1'
                linker.args "/LIBPATH:C:\\Program Files\\boost\\boost_1_65_1_test\\lib64-msvc-14.1"
                linker.args "/DEFAULTLIB:C:\\Program Files\\cfitsio\\lib\\cfitsio.lib"
                cppCompiler.args "/IC:\\Users\\Errox\\cfitsio\\include" , "/IC:\\Program Files\\boost\\boost_1_65_1_test" , '/EHsc'
                cppCompiler.args '/std:c++14'
                cppCompiler.args '/arch (x64)'
                cppCompiler.args '/MT'
                if(buildType == buildTypes.debug) {
                    cppCompiler.args '/Zi', '/FS'
                    cppCompiler.define 'DEBUG'
                    linker.args '/DEBUG'
                }
            }

        }
        withType(StaticLibraryBinarySpec) {
          if (toolChain in Gcc || toolChain in Clang){
            cppCompiler.args '-fPIC'
          }
        }

    }

    components {
        eigen(NativeLibrarySpec) {
            targetPlatform "x64"
            sources.cpp {
                source {}
                exportedHeaders {
                    srcDir "src/third_party_libs/Eigen"
                }
            }
        }
        superphot(NativeLibrarySpec) {
            targetPlatform "x64"
            sources.cpp {
                lib library: "eigen"
                source {
                    srcDir "src/Core"
                    include "**/*.cpp"
                }
                source {
                    srcDir "src/IO"
                    include "**/OutputArray.cpp"
                }
                source {
                    srcDir "src/Background"
                    include "**/*.cpp"
                }
                source {
                    srcDir "src/PSF"
                    include "**/*.cpp"
                }
                source {
                    srcDir "src/FitPSF"
                    include "**/*.cpp"
                    exclude "**/*SDK*.cpp"
                    exclude "**/fitpsf.cpp"
                }
                source {
                    srcDir "src/SubPixPhot"
                    include "**/*.cpp"
                }
                source {
                    srcDir "src/Core"
                    include "**/*.cpp"
                }
                exportedHeaders {
                    srcDir "src/Background/"
                }
                exportedHeaders {
                    srcDir "src/PSF/"
                }
                exportedHeaders {
                    srcDir "src/IO/"
                }
                exportedHeaders {
                    srcDir "src/FitPSF/"
                    exclude "**/*SDK*.h"
                }
            }
        }
    }
}

doxygen {
    generate_html true
    template "documentation/doxygen/Doxyfile"
    source "src/Background"
    source "src/Core"
    source "src/FitPSF"
    source "src/FitSubpix"
    source "src/IO"
    source "src/PSF"
    source "src/SubPixPhot"
    source "src/SubtractPSF"
    source "src/VisualizePSFMap"
    source "documentation/doxygen"
    include "**/*.h"
    include "**/*.cpp"
    include "**/*.py"
    include "**/*.md"
}

def findLibraryLinux(String libNameStart)
{
    def libInfoList
    def bestMatch = false
    def absLibFileName
    def multipleCandidates = false
    try {
        libInfoList = "ldconfig -p".execute().text.split('\n')
    } catch (Exception ex) {
        throw new ProjectConfigurationException(
            "Failed to execute command: ldconfig -p",
            new NullPointerException()
        )
    }
    def libSearch = ~(
        "lib(?<name>${libNameStart}.*)\\.so\\.(?<version>[0-9.]*)\\s+.*=>"
    )
    for(String libInfo : libInfoList) {
        def match = libInfo =~ libSearch
        if(match) {
            absLibFileName = libInfo.split('=>')[1].trim()
            if(match.group("name") == libNameStart)
                return [match.group("name"),
                        match.group("version"),
                        absLibFileName]
            if(bestMatch) {multipleCandidates = true}
            bestMatch = match
        }
    }
    if(bestMatch) {
        if(multipleCandidates) {
            throw new ProjectConfigurationException(
                "Multiple link candidates found for library "
                +
                "${libNameStart}:\n",
                new NullPointerException()
            )
        }
        return [bestMatch.group("name"),
                bestMatch.group("version"),
                absLibFileName]
    } else {
        throw new ProjectConfigurationException(
            "No candidate ${libNameStart} library found!",
            new NullPointerException()
        );
    }
}

def findLibraryMacOS(String libNameStart)
{
    return [libNameStart, 0, 0]
    def libFullPath
    def sout = new ByteArrayOutputStream()
    def serr = new ByteArrayOutputStream()
    exec {
        commandLine "/usr/bin/ld"
        args "-l${libName}", "-dylib", "-arch", "x86_64", "-t", "-w"
        for(String path : System.env.LIBRARY_PATH.split(':')) {
            if(path) args "-L${path}"
        }
        standardOutput = sout
        errorOutput = serr
    }

    logger.debug("Out: '" + sout.toString() + "'")
    logger.debug("Err: '" + serr.toString() + "'")

    libFullPath = sout.toString().trim()
    logger.debug("Result: '" + libFullPath + "'")
    if(!libFullPath)
        throw new ProjectConfigurationException(
            "No candidate ${libName} library found!",
            new NullPointerException()
        );

    def versionSearch = ~(
        "${libName}[0-9.]*.dylib \\(.* current version (?<version>[0-9.]*)"
    )

    def otoolOutput = (
        "otool -L ${libFullPath}".execute().text.split('\n')
    )
    for(String line : otoolOutput) {
        def match = line =~ versionSearch
        if(match) return [libName, match.group("version"), libFullPath]
    }
    throw new ProjectConfigurationException(
        "Failed to determine the version of ${libName} library!",
        new NullPointerException()
    );
}

def findLibraryWindows(String libNameStart)
{

}

def findLibrary(String libNameStart)
{
    if(OperatingSystem.current().isLinux())
        return findLibraryLinux(libNameStart)
    else if(OperatingSystem.current().isMacOsX())
        return findLibraryMacOS(libNameStart)
    else if(OperatingSystem.current().isWindows())
        return findLibraryWindows(libNameStart)
    else {
        throw new ProjectConfigurationException(
            "Compiling on non-linux or Mac operating systems not currently "
            +
            "supported!",
            new NullPointerException()
        );
    }
}

def ensureLibraryVersion(String libNameStart,
                         Map versionRange = [:])
{
    def(String libName,
        String libVersion,
        String libAbsFileName) = findLibrary(libNameStart)
    if(libVersion == "0.0.0") return libName
    if(versionRange.containsKey('min'))
        assert(libVersion >= versionRange['min'])
    if(versionRange.containsKey('max'))
        assert(libVersion <= versionRange['max'])
    return libName
}

def getGSLLinkerArgs()
{
    if(OperatingSystem.current().isWindows()) {
        return ["-lgsl", "-lgslcblas"]
    } else {
        try {
            return "gsl-config --libs".execute().text.tokenize()
        } catch (ReportedException) {
            throw new MissingResourceException(
                "Unable to configure linking with GSL: gsl-config --libs " +
                "failed!"
            );
        }
    }
}

task showCompilerOptions {
   doLast {
      println '\n-----------------------------------------------------\n'
      println 'Compiler options:'
      FileTree tree = fileTree('build').include('**/options.txt')
      // Iterate over the contents of a tree
      tree.each {File file ->
          println 'Content of file ' + file + ':\n'
          println file.text
          println '------\n'
      }
   }
}

task showCompilerOutput {
   dependsOn showCompilerOptions
   doLast {
      println '\n-----------------------------------------------------\n'
      println 'Compiler output:'
      FileTree tree = fileTree('build').include('**/output.txt')
      // Iterate over the contents of a tree
      tree.each {File file ->
          println 'Content of file ' + file + ':\n'
          println file.text
          println '------\n'
      }
   }
}
